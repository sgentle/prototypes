// Generated by CoffeeScript 1.10.0
(function() {
  var attach, defaultComp, diff, diffcomp, disp, sortedInsert;

  defaultComp = function(a, b) {
    return a > b;
  };

  sortedInsert = function(ary, item, greater) {
    var end, i, start;
    if (greater == null) {
      greater = defaultComp;
    }
    start = 0;
    end = ary.length;
    while (start < end) {
      i = Math.floor((start + end) / 2);
      if (greater(item, ary[i])) {
        start = i + 1;
      } else {
        end = i;
      }
    }
    ary.splice(start, 0, item);
    return ary;
  };

  diffcomp = function(path1, path2) {
    return path1.d > path2.d;
  };

  disp = function(str1, str2, path) {
    var ret;
    ret = [];
    while (path) {
      if (path.dir === 0) {
        ret.unshift("-" + str1[path.prev.x]);
      }
      if (path.dir === 1) {
        ret.unshift("+" + str2[path.prev.y]);
      }
      if (path.dir === 2) {
        ret.unshift("=" + str1[path.prev.x]);
      }
      path = path.prev;
    }
    return ret.join('');
  };

  diff = function(str1, str2) {
    var d, dir, lastpdir, n, p, paths, prev, ret, thisPath, visited, x, y;
    visited = {};
    paths = [
      {
        x: 0,
        y: 0,
        d: 0,
        dir: -1,
        prev: null
      }
    ];
    n = 0;
    while (!(!paths[0] || (paths[0].x === str1.length) && (paths[0].y === str2.length))) {
      thisPath = paths.shift();
      x = thisPath.x, y = thisPath.y, dir = thisPath.dir, d = thisPath.d, prev = thisPath.prev;
      if (visited[x + ":" + y] || (x > str1.length) || (y > str2.length)) {
        continue;
      }
      visited[x + ":" + y] = true;
      if (str1[x] && (str1[x] === str2[y])) {
        sortedInsert(paths, {
          x: x + 1,
          y: y + 1,
          d: d,
          dir: 2,
          prev: thisPath
        }, diffcomp);
      } else if (dir === 0) {
        sortedInsert(paths, {
          x: x + 1,
          y: y,
          d: d + 1,
          dir: 0,
          prev: thisPath
        }, diffcomp);
        sortedInsert(paths, {
          x: x,
          y: y + 1,
          d: d + 1,
          dir: 1,
          prev: thisPath
        }, diffcomp);
      } else {
        sortedInsert(paths, {
          x: x,
          y: y + 1,
          d: d + 1,
          dir: 1,
          prev: thisPath
        }, diffcomp);
        sortedInsert(paths, {
          x: x + 1,
          y: y,
          d: d + 1,
          dir: 0,
          prev: thisPath
        }, diffcomp);
      }
    }
    p = paths[0];
    ret = [];
    lastpdir = null;
    while (p) {
      if (p.dir !== lastpdir && p.dir !== -1) {
        ret.unshift({
          t: "-+="[p.dir],
          c: []
        });
      }
      lastpdir = p.dir;
      switch (p.dir) {
        case 0:
        case 2:
          ret[0].c.push(str1[p.prev.x]);
          break;
        case 1:
          ret[0].c.push(str2[p.prev.y]);
      }
      p = p.prev;
    }
    return ret;
  };

  attach = function(el) {
    var elset, observer;
    elset = new Set();
    observer = new MutationObserver(function(mutations) {
      var j, len, mut, results;
      results = [];
      for (j = 0, len = mutations.length; j < len; j++) {
        mut = mutations[j];
        if (mut.type === 'childList') {
          console.log('target', mut.target);
          console.log('added', mut.addedNodes);
          results.push(console.log('removed', mut.removedNodes));
        } else if (mut.type === 'characterData') {
          console.log('target', mut.target);
          results.push(console.log(diff(mut.oldValue, mut.target.data)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    });
    return observer.observe(el, {
      childList: true,
      characterData: true,
      subtree: true,
      characterDataOldValue: true
    });
  };

  if (typeof window === 'undefined') {
    module.exports = {
      diff: diff,
      sortedInsert: sortedInsert
    };
  } else {
    window.пере = function(sel) {
      var el, j, len, ref, results;
      ref = document.querySelectorAll(sel);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        results.push(attach(el));
      }
      return results;
    };
  }

}).call(this);
